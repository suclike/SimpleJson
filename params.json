{
  "name": "SimpleJson",
  "tagline": "A simple and lightning fast JSON Parser for Android with barely any runtime overhead!",
  "body": "* **No slow reflection, full performance**: SimpleJson uses compile time annotation processing to generate performant and efficient implementations of models and parsers. No performance hit due to reflection at runtime.\r\n* **Most errors caught at compile time**: SimpleJson will check for most common errors at compile time and give you useful and detailed error messages.\r\n* **Generates real debuggable code**: You can view the model and parser implementations at any time and debug any error and behaviour. No more guessing what went wrong.\r\n* **Easy to use and quick to setup**: Getting SimpleJson to work requires no setup and after adding only a few annotations on your models you are good to go.\r\n* **Works with ProGuard**: With SimpleJson you don't need to mess around with ProGuard rules and worry about keeping the right classes. Every bit of your code can be obfuscated without worrying about a thing.\r\n* **Works with Retrofit2**: SimpleJson automatically detects if Retrofit2 is used in your project and automatically sets everything up so that Retrofit2 can work with your entities seamlessly!\r\n\r\n# How to add it to your project\r\n\r\nIf you are using the new Jack compiler all you have to add is these two dependencies:\r\n\r\n```groovy\r\ncompile 'com.github.wrdlbrnft:simple-json:0.1.0.9'\r\nannotationProcessor 'com.github.wrdlbrnft:simple-json-processor:0.1.0.9'\r\n```\r\n\r\nIf you are not using Jack you can use the android-apt Gradle plugin instead of using the `annotationProcessor` configuration \r\nto add the annotation processor of SimpleJson to your module. \r\n\r\n# Basic Usage\r\n\r\nSimpleJson works exclusively with interfaces. It generates an implementation of those interface for you as well as a parser which translates it into json. \r\nTo get started just annotate your interface with `@JsonEntity` and use `@FieldName` to tell SimpleJson how to map elements in the json to the getters.\r\n\r\n```java\r\n@JsonEntity\r\npublic interface ExampleModel {\r\n    \r\n  @FieldName(\"id\")\r\n  long getId();\r\n\r\n  @FieldName(\"text\")\r\n  String getText();\r\n}\r\n```\r\n\r\nA JSON that corrosponds to the above interface would look something like this:\r\n\r\n```json\r\n{\r\n  \"text\": \"some example text\",\r\n  \"id\": 27\r\n}\r\n```\r\n\r\nFor each interface a factory class is generated which can be used to turn json into your entities or the other way around. \r\nThese factory classes are dynamically generated and are usually names by adding an s to the end of the interface name. If the interface name already ends with an s then the word Factory is appended.\r\n\r\n```java\r\nExampleModel model = ExampleModels.fromJson(json);\r\n```\r\n\r\nIf you have an array of json objects like this:\r\n\r\n```json\r\n[\r\n  {\r\n    \"text\": \"qwerty\",\r\n    \"id\": 27\r\n  },\r\n  {\r\n    \"text\": \"asdfdsa\",\r\n    \"id\": 37\r\n  },\r\n  {\r\n    \"text\": \"hello world\",\r\n    \"id\": 47\r\n  }\r\n]\r\n```\r\n\r\nThen you can parse that json by calling `fromJsonArray()`:\r\n\r\n```java\r\nList<ExampleModel> models = ExampleModels.fromJsonArray(json);\r\n```\r\n\r\nTranslating an entity into json from an entity or a `Collection` of entities works by calling `toJson()`:\r\n\r\n```java\r\nString json = ExampleModels.toJson(model);\r\n...\r\nList<ExampleModel> models = ...;\r\nString jsonArray = SimpleJson.toJson(ExampleModel.class, models);\r\n```\r\n\r\nEach factory class also has a `create()` method which can be used to create new instances of your entities without you having to implement them:\r\n\r\n```java\r\nExampleModel model = ExampleModels.create(27L, \"text\");\r\n```\r\n\r\n# Optional fields\r\n\r\nIf there is an optional element in a JSON you want to parse just annotate the corrosponding getter with `@Optional`. If the element is missing from the json then it will be parsed as `null`. If an element is not annotated with `@Optional` and it is missing from the JSON than a `SimpleJsonException` will be thrown! \r\n\r\n```java\r\n@JsonEntity\r\npublic interface ExampleModel {\r\n    \r\n  @FieldName(\"id\")\r\n  long getId();\r\n\r\n  @FieldName(\"text\")\r\n  String getText();\r\n\r\n  @Optional\r\n  @FieldName(\"value\")\r\n  String getOptionalValue();\r\n}\r\n```\r\n\r\n**Note:** Methods annotated with `@Optional` cannot return primitive values! Use boxed values instead.\r\n\r\n# Mapping Enums\r\n\r\nSimpleJson can map Enums from and to JSON for you! To use an enum in SimpleJson just add the `@JsonEnum` annotation. You can then define the mappings of each value with the `@MapTo` annotation.\r\n You can also use `@MapDefault` to define default mapping values if no other mapping applies. If no default value is defined then a `SimpleJsonException` will be thrown.\r\n\r\n```java\r\n@JsonEnum\r\npublic enum ExampleEnum {\r\n\r\n  @MapTo(\"a\")\r\n  VALUE_A,\r\n    \r\n  @MapTo(\"b\")\r\n  VALUE_B,\r\n    \r\n  @MapTo(\"c\")\r\n  VALUE_C\r\n}\r\n```\r\n\r\nBy annotating the enum like above `VALUE_A` will be mapped to the String `\"a\"` in the JSON, `VALUE_B` will be mapped to `\"b\"` and so on. If you parse a JSON and the String `\"c\"` is encountered in an element which should be parsed as `ExampleEnum` then it will be mapped to `VALUE_C`, if `\"b\"` is encountered it will be mapped to `VALUE_B` and so on.\r\n\r\n# Collections and Child Entities\r\n\r\nYou can also work with complex models and child entities! Consider some like this:\r\n\r\n```java\r\n@JsonEntity\r\npublic interface Parent {\r\n\r\n  @FieldName(\"types\")\r\n  List<Type> getTypes();\r\n    \r\n  @FieldName(\"children\")\r\n  Set<Child> getChildren();\r\n}\r\n\r\n@JsonEntity\r\npublic interface Child {\r\n\r\n  @FieldName(\"text\")\r\n  String getText();\r\n  \r\n  @FieldName(\"enabled\")\r\n  boolean isEnabled();\r\n  \r\n  @FieldName(\"value\")\r\n  double getValue();\r\n}\r\n\r\n@JsonEnum\r\npublic enum Type {\r\n  @MapTo(\"a\") A,\r\n  @MapTo(\"b\") B,\r\n  @MapTo(\"c\") C\r\n  @MapDefault D\r\n}\r\n```\r\n\r\nCollections like `List` or `Set` are represented as array in JSON. Child entities will be parsed recursively and if a `Parent` entity is translated to JSON the result would look something like this:\r\n\r\n```json\r\n{\r\n  \"types\": [\"a\", \"b\"],\r\n  \"children\": [\r\n    {\r\n      \"text\": \"some text\",\r\n      \"enabled\": 1,\r\n      \"value\": 23.7\r\n    },\r\n    {\r\n      \"text\": \"some other text\",\r\n      \"enabled\": 0,\r\n      \"value\": 0.0\r\n    },\r\n    {\r\n      \"text\": \"example\",\r\n      \"enabled\": 1,\r\n      \"value\": 1234.5\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n# Retrofit2\r\n\r\nIf you are using Retrofit2 to make your API calls then SimpleJson will automatically generate a \r\n`SimpleJsonConverterFactory` for you which enables Retrofit2 to seamlessly work with your SimpleJson entities.\r\nYou can add the `SimpleJsonConverterFactory` when you create your `Retrofit` instance like this:\r\n\r\n```java\r\nRetrofit retrofit = new Retrofit.Builder()\r\n    .baseUrl(\"https://your.backend.com\")\r\n    .addConverterFactory(new SimpleJsonConverterFactory())\r\n    .build();\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}